tmp_vect  = rep(names(tmp_ratio), round(tmp_ratio*n_forSim))
if (length(tmp_vect) < nrow(df_sim)) tmp_vect = c(tmp_vect, rep(names(tmp_ratio[tmp_ratio == max(tmp_ratio)]),
nrow(df_sim) - length(tmp_vect)))
if(length(tmp_vect) > nrow(df_sim)) tmp_vect = tmp_vect[-length(tmp_vect)]
df_sim[,iv] = factor(tmp_vect)
} # otherwise assume the same number of nominal and ordinal observations in the simulated sample.
}
df_sim$perf_pred_dv = predict(lm, newdata=df_sim)
sd_resid  = sd(lm$residuals)
df_sim[,dv] <- rnorm(n_forSim,
mean(df_sim$perf_pred_dv),
sd_resid)
return(df_sim)
}
fake = sim_dat_lm(lm, n_forSim)               #generate a fake dataset
lm_tmp = suppressWarnings(suppressMessages(lm(lm$call$formula,
data = fake)))
coefs = data.frame(summary(lm_tmp)$coefficients)
colnames(coefs) = c("est", "se","t","p")
for_return = coefs$p < alpha
names(for_return) = rownames(coefs)
return(for_return)
}
# close(pb)
parallel::stopCluster(cl)
return(colMeans(signif))
}
current_power = sim_pow_lm(lm)[effect]
cat(paste("Current power for", names(current_power),"based on existing data is:", current_power, "\n\n"))
if (all(current_power >= desired_power)) {
cat("No need to calculate further\n\n")
return(nrow(lm$model))
} else {
n_obs = nrow(lm$model) + n_step
while (all(current_power < desired_power)){
if(verbose) cat(paste("\tChecking if a sample of", n_obs, "observations is enough to meet the deisred power...\n"))
current_power = sim_pow_lm(lm, n_obs)[effect]
n_obs = n_obs + n_step
}
if(verbose) cat(paste("A sample of", n_obs, "should be sufficient to power for the effect of",
effect, "at a power of", desired_power, ".\n"))
return(n_obs)
}
}
determine_n_lm = function(lm,
effect,#=NULL,
n_sims=10000,
alpha=.05,
n_step=1,
desired_power=.8,
verbose=T) {
post_hoc_sim_pow_lm = function (lm,
n_forSims=NULL,
n_sims=10000,
alpha=.05){
cl = parallel::makeCluster(parallel::detectCores())
doSNOW::registerDoSNOW(cl)
pb = txtProgressBar(min = 1, max = n_sims, style = 3)
progress <- function(n) setTxtProgressBar(pb, n)
opts <- list(progress=progress)
signif = foreach (s = 1:n_sims, .combine = rbind #, .options.snow=opts
) %dopar% {
sim_dat_lm = function (lm,
n_forSim=NULL){
warning("This function doesn't work yet, and has not been fully tested...")
warning("This function assumes all numeric variables in the model are normally distributed, and the same number of observations of all factor (nominal and ordinal) variables.")
if(is.null(n_forSim)) n_forSim = nrow(lm$model)
coefs = data.frame(summary(lm)$coefficients)
colnames(coefs) = c("est", "se","t","p")
coefs$sd = coefs$se * sqrt(nrow(lm$model))
dv = as.character(lm$terms)[2]
x_term = as.character(lm$terms)[3]
ivs = unlist(strsplit(x_term, " \\+ "))
# if(is.null(effect)) effect = ivs
observation = rep(1:n_forSim)     # Create a number of rows
df_sim = data.frame(observation)
for (iv in ivs){ # For each IV...
if (is.numeric(lm$model[,iv])) { # if it is numeric...
tmp_mu = mean(lm$model[,iv]) # calculate the mean...
tmp_sd = sd(lm$model[,iv])   # and standard deviation...
df_sim[,iv] = rnorm(n_forSim, tmp_mu, tmp_sd) # use those to generate a simulated sample...
} else {
tmp_ratio = table(lm$model[,iv])/sum(table(lm$model[,iv]))
tmp_vect  = rep(names(tmp_ratio), round(tmp_ratio*n_forSim))
if (length(tmp_vect) < nrow(df_sim)) tmp_vect = c(tmp_vect, rep(names(tmp_ratio[tmp_ratio == max(tmp_ratio)]),
nrow(df_sim) - length(tmp_vect)))
if(length(tmp_vect) > nrow(df_sim)) tmp_vect = tmp_vect[-length(tmp_vect)]
df_sim[,iv] = factor(tmp_vect)
} # otherwise assume the same number of nominal and ordinal observations in the simulated sample.
}
df_sim$perf_pred_dv = predict(lm, newdata=df_sim)
sd_resid  = sd(lm$residuals)
df_sim[,dv] <- rnorm(n_forSim,
mean(df_sim$perf_pred_dv),
sd_resid)
return(df_sim)
}
fake = sim_dat_lm(lm, n_forSim)               #generate a fake dataset
lm_tmp = suppressWarnings(suppressMessages(lm(lm$call$formula,
data = fake)))
coefs = data.frame(summary(lm_tmp)$coefficients)
colnames(coefs) = c("est", "se","t","p")
for_return = coefs$p < alpha
names(for_return) = rownames(coefs)
return(for_return)
}
# close(pb)
parallel::stopCluster(cl)
return(colMeans(signif))
}
current_power = sim_pow_lm(lm)[effect]
cat(paste("Current power for", names(current_power),"based on existing data is:", current_power, "\n\n"))
if (all(current_power >= desired_power)) {
cat("No need to calculate further\n\n")
return(nrow(lm$model))
} else {
n_obs = nrow(lm$model) + n_step
while (all(current_power < desired_power)){
if(verbose) cat(paste("\tChecking if a sample of", n_obs, "observations is enough to meet the deisred power...\n"))
current_power = sim_pow_lm(lm, n_obs)[effect]
n_obs = n_obs + n_step
}
if(verbose) cat(paste("A sample of", n_obs, "should be sufficient to power for the effect of",
effect, "at a power of", desired_power, ".\n"))
return(n_obs)
}
}
determine_n_lm(lm_overall, n_step = 5)
sim_dat_lm(lm_overall, 500)
post_hoc_sim_pow_lm(lm_overall, 500)
warnings()
post_hoc_sim_pow_lm(lm_overall, 5000)
post_hoc_sim_pow_lm(lm_overall, 50000)
source("~/GitHub/puRduePsych/R/sim_pow_lm.R", echo=TRUE)
determine_n_lm(lm_overall, n_step = 1000)
source("~/GitHub/puRduePsych/R/sim_pow_lm.R", echo=TRUE)
determine_n_lm(lm_overall, n_step = 1000)
is.null(effect)
exists(effect)
exists(effect)
effect
!effect
exists("effect")
if(!exists("lm")) stop("lm not defined.")
source("~/GitHub/puRduePsych/R/sim_pow_lm.R", echo=TRUE)
lm_overall = lm(variet94 ~ age94 + gender + parent90 + cenhod90 + open90 + consc90 + extra90 + agree90 + neuro90,
data=df_PSY631Data)
determine_n_lm(lm_overall, "age94")
warnings()
determine_n_lm(lm_overall, "age94", n_sims=100, n_step=100)
post_hoc_sim_pow_lm(lm_overall, 10000)
source("~/GitHub/puRduePsych/R/sim_pow_lm.R", echo=TRUE)
determine_n_lm()
determine_n_lm(lm_overall)
source("~/GitHub/puRduePsych/R/sim_pow_lm.R", echo=TRUE)
determine_n_lm(lm_overall, "(Intercept)", n_step = 111)
warnings()
determine_n_lm(lm_overall, "(Intercept)", n_step = 1111)
source("~/GitHub/puRduePsych/R/sim_pow_lm.R", echo=TRUE)
?txtProgressBar
############################
#One Sample
my.N <- 40               #sample size
my.df <- my.N-1          #degrees of freedom
#One Sample
DV <- rnorm(my.N, mean = 0.2, sd = 1);    #Create Data
#Look at data
hist(DV,20)
#One tailed test alternative hypothesis is greater than zero
( my.t <- t.test(DV, alternative="greater", var.equal=TRUE) )
############################
#Two Sample
my.N <- 20               #sample size per group
groups <- as.factor( rbind( cbind(rep(1,my.N)), cbind(rep(2,my.N)) ) )     #Create Data
DVg1 <- rnorm(my.N, mean = 0, sd = 1)                                      #Create Data
DVg2 <- rnorm(my.N, mean = 0.2, sd = 1)                                    #Create Data
#Look at data
hist(DVg1,20)
#Overlay plot of second group in blue
par(new=TRUE)
hist(DVg2,20, col="blue")
?t.test
sim_dat_t_z_anova = function(groups,
n,
means,
sds){
if(length(groups) > 1 | !is.integer(groups) | groups <= 0) stop("'groups' must be a single positive integer.")
if(length(n) != 1 & length(n) != groups) stop("'n' must be either a single positive integer or a vector of positive integers
with the same length as the number of groups specified.")
if(length(means) != groups | length(sds) != groups) stop("Means and standard deviations must be specified for each group.")
if(!all(sds > 0)) stop("All standard deviation values must be positive.")
if(length(n) == 1) n = rep(n, groups)
sim_dat = data.frame(group = c(), DV = c())
for(g in 1:groups){
sim_dat = rbind(sim_dat,
data.frame(group = rep(g, n[g]),
DV = rnorm(n[g], means[g], sds[g])))
}
return(sim_dat)
}
test_data = sim_dat_t_z_anova(1,25,3,1)
length(1)
length(1) > 1
is.integer(1)
integer(1)
integer(1.2)
integer(3)
as.integer(3)
as.integer(1)
as.integer(1.2)
my_doubles1 <- c(1.1 , 2.2 , 3.3, 4.4 )
my_doubles2 <- c(1   , 2   , 3  , 4   )
my_integers <- c(1L  , 2L  , 3L , 4L  )
my_random   <- c(1L  , 2L  , 3L , 4   )
#implementing the is.integer() function
is.integer(my_doubles1)
is.integer(my_doubles2)
is.integer(my_integers)
is.integer(my_random)
sim_dat_t_z_anova = function(groups,
n,
means,
sds){
if(length(groups) > 1 | !is.integer(groups) | groups <= 0) stop("'groups' must be a single positive integer.")
if(length(n) != 1 & length(n) != groups) stop("'n' must be either a single positive integer or a vector of positive integers
with the same length as the number of groups specified.")
if(length(means) != groups | length(sds) != groups) stop("Means and standard deviations must be specified for each group.")
if(!all(sds > 0)) stop("All standard deviation values must be positive.")
if(length(n) == 1) n = rep(n, groups)
sim_dat = data.frame(group = c(), DV = c())
for(g in 1:groups){
sim_dat = rbind(sim_dat,
data.frame(group = rep(g, n[g]),
DV = rnorm(n[g], means[g], sds[g])))
}
return(sim_dat)
}
sim_dat_t_z_anova = function(groups,
n,
means,
sds){
if(length(groups) > 1 | !all.equal(groups, as.integer(groups)) | groups <= 0) stop("'groups' must be a single positive integer.")
if(length(n) != 1 & length(n) != groups) stop("'n' must be either a single positive integer or a vector of positive integers
with the same length as the number of groups specified.")
if(length(means) != groups | length(sds) != groups) stop("Means and standard deviations must be specified for each group.")
if(!all(sds > 0)) stop("All standard deviation values must be positive.")
if(length(n) == 1) n = rep(n, groups)
sim_dat = data.frame(group = c(), DV = c())
for(g in 1:groups){
sim_dat = rbind(sim_dat,
data.frame(group = rep(g, n[g]),
DV = rnorm(n[g], means[g], sds[g])))
}
return(sim_dat)
}
test_data = sim_dat_t_z_anova(1,25,3,1)
test_data = sim_dat_t_z_anova(2,25,3,1)
test_data = sim_dat_t_z_anova(2,25,c(3, 2),c(1,1))
sim_dat_t_z_anova = function(groups,
n,
means,
sds){
if(length(groups) > 1 | !all.equal(groups, as.integer(groups)) | groups <= 0) stop("'groups' must be a single positive integer.")
if(length(n) != 1 & length(n) != groups) stop("'n' must be either a single positive integer or a vector of positive integers
with the same length as the number of groups specified.")
if(length(means) != groups) stop("Means must be specified for each group.")
if(length(sds) != 1 & length(sds) != groups) stop("'sds' must be either a single standard deviation value or
a vector of values specifying the sd for each group")
if(!all(sds > 0)) stop("All standard deviation values must be positive.")
if(length(n) == 1) n = rep(n, groups)
if(length(sds) == 1) sds = rep(sds, groups)
sim_dat = data.frame(group = c(), DV = c())
for(g in 1:groups){
sim_dat = rbind(sim_dat,
data.frame(group = rep(g, n[g]),
DV = rnorm(n[g], means[g], sds[g])))
}
return(sim_dat)
}
test_data = sim_dat_t_z_anova(2,25,c(3, 2),1)
View(test_data)
test_t_test = t.test(test_data$DV)
sim_pow_t_z_anova = function(groups,
n,
means,
sds,
n_sims=10000,
alternative = 'two-sided',
eq_var = T,
mu = 0,
paired = F,
alpha = 0.05){
dataFrames = list()
sig = c()
for(s in 1:n_sims){
dataFrames[[s]] = sim_dat_t_z_anova(groups, n, means, sds)
}
if(groups == 1){
for (df in dataFrames){
tmp_test = t.test(df$DV, alternative = alternative, mu = mu, conf.level = 1-alpha)
sig = c(sig, tmp_test$p.value < alpha)
}
}
}
sim_pow_t_z_anova(1,25,2,1)
sim_pow_t_z_anova = function(groups,
n,
means,
sds,
n_sims=10000,
alternative = 'two.sided',
eq_var = T,
mu = 0,
paired = F,
alpha = 0.05){
dataFrames = list()
sig = c()
for(s in 1:n_sims){
dataFrames[[s]] = sim_dat_t_z_anova(groups, n, means, sds)
}
if(groups == 1){
for (df in dataFrames){
tmp_test = t.test(df$DV, alternative = alternative, mu = mu, conf.level = 1-alpha)
sig = c(sig, tmp_test$p.value < alpha)
}
}
}
sim_pow_t_z_anova(1,25,2,1)
sim_pow_t_z_anova = function(groups,
n,
means,
sds,
n_sims=10000,
alternative = 'two.sided',
eq_var = T,
mu = 0,
paired = F,
alpha = 0.05){
dataFrames = list()
sig = c()
for(s in 1:n_sims){
dataFrames[[s]] = sim_dat_t_z_anova(groups, n, means, sds)
}
if(groups == 1){
for (df in dataFrames){
tmp_test = t.test(df$DV, alternative = alternative, mu = mu, conf.level = 1-alpha)
sig = c(sig, tmp_test$p.value < alpha)
}
}
return(mean(sigs))
}
sim_pow_t_z_anova(1,25,2,1)
sim_pow_t_z_anova = function(groups,
n,
means,
sds,
n_sims=10000,
alternative = 'two.sided',
eq_var = T,
mu = 0,
paired = F,
alpha = 0.05){
dataFrames = list()
sig = c()
for(s in 1:n_sims){
dataFrames[[s]] = sim_dat_t_z_anova(groups, n, means, sds)
}
if(groups == 1){
for (df in dataFrames){
tmp_test = t.test(df$DV, alternative = alternative, mu = mu, conf.level = 1-alpha)
sig = c(sig, tmp_test$p.value < alpha)
}
}
return(mean(sig))
}
sim_pow_t_z_anova(1,25,2,1)
sim_pow_t_z_anova(1,25,1,1)
sim_pow_t_z_anova(1,25,1,.5)
sim_pow_t_z_anova(1,25,0,1)
sim_pow_t_z_anova(1,25,0,1)
sim_pow_t_z_anova(1,25,0,1, mu=1)
sim_pow_t_z_anova(1,25,0,1)
sim_pow_t_z_anova(1,25,0,1)
sim_pow_t_z_anova(1,25,0,1)
sim_pow_t_z_anova(1,25,0,1, n_sims = 100000)
car::Anova(DV ~ group, data = test_data)
test_anova = car::Anova(aov(DV ~ group, data = test_data))
test_anova
test_anova$`Pr(>F)`
?car::Anova
test_anova = aov(DV ~ group, data = test_data)
test_anova$qr
test_anova$effects
test_anova = summary(aov(DV ~ group, data = test_data))
test_anova
test_anova$`Pr(>F)`
test_anova[`Pr(>F)`]
test_anova = data.frame(summary(aov(DV ~ group, data = test_data)))
test_anova = summary(aov(DV ~ group, data = test_data))
typeof(test_anova)
test_anova[[2]]
test_anova[[1]]
test_anova[[1]]$`Pr(>F)`
test_anova[[1]]$`Pr(>F)`[1]
source("~/GitHub/puRduePsych/R/sim_pow_t_z_anova.R", echo=TRUE)
sim_pow_t_z_anova(3,c(19,25,30),c(10,11,12), 2)
sim_pow_t_z_anova(3,c(19,25,30),c(11,11,12), .5)
sim_pow_t_z_anova(3,c(19,25,30),c(11,11,12), 3)
sim_pow_t_z_anova(3,c(19,25,30),c(11,11,11), 3)
sim_pow_t_z_anova(3,20,c(11,11,11), 3)
test_data = sim_dat_t_z_anova(3,20,c(11,11,11), 3)
aov(DV~group, test_data)
summary(aov(DV~group, test_data))
View(test_data)
source("~/GitHub/puRduePsych/R/sim_pow_t_z_anova.R", echo=TRUE)
sim_pow_t_anova(3,20,c(11,11,11),1)
source("~/GitHub/puRduePsych/R/sim_pow_t_z_anova.R", echo=TRUE)
sim_pow_t_anova(3,20,c(11,11,11),1)
require(parallel)
require(doSNOW)
source("~/GitHub/puRduePsych/R/sim_pow_t_z_anova.R", echo=TRUE)
sim_pow_t_anova(3,20,c(11,11,11),1)
warnings()
sim_pow_t_anova(3,20,c(11,11,11),1)
source("~/GitHub/puRduePsych/R/sim_pow_t_z_anova.R", echo=TRUE)
sim_pow_t_anova(3,20,c(11,11,11),1)
sim_pow_t_anova = function(groups,
n,
means,
sds,
n_sims=10000,
alternative = 'two.sided',
eq_var = T,
mu = 0,
paired = F,
alpha = 0.05,
anova_type = 3){
requireNamespace("parallel")
requireNamespace("doSNOW")
requireNamespace("car")
cl = parallel::makeCluster(parallel::detectCores())
doSNOW::registerDoSNOW(cl)
pb = txtProgressBar(min = 1, max = n_sims, style = 3)
progress <- function(n) setTxtProgressBar(pb, n)
opts <- list(progress=progress)
signif = foreach (s = 1:n_sims, .combine = rbind, .options.snow=opts
) %dopar% {
sim_dat_t_anova = function(groups,
n,
means,
sds){
if(length(groups) > 1 | !all.equal(groups, as.integer(groups)) | groups <= 0) stop("'groups' must be a single positive integer.")
if(length(n) != 1 & length(n) != groups) stop("'n' must be either a single positive integer or a vector of positive integers
with the same length as the number of groups specified.")
if(length(means) != groups) stop("Means must be specified for each group.")
if(length(sds) != 1 & length(sds) != groups) stop("'sds' must be either a single standard deviation value or
a vector of values specifying the sd for each group")
if(!all(sds > 0)) stop("All standard deviation values must be positive.")
if(length(n) == 1) n = rep(n, groups)
if(length(sds) == 1) sds = rep(sds, groups)
sim_dat = data.frame(group = c(), DV = c())
for(g in 1:groups){
sim_dat = rbind(sim_dat,
data.frame(group = rep(g, n[g]),
DV = rnorm(n[g], means[g], sds[g])))
}
return(sim_dat)
}
fake = sim_dat_t_anova(groups, n, means, sds)   #generate a fake dataset
pval = ifelse(groups == 1,
t.test(df$DV, alternative = alternative, mu = mu, conf.level = 1-alpha)$p.val,
ifelse(groups == 2,
t.test(DV ~ group, data = df, alternative = alternative, mu = mu, conf.level = 1-alpha)$p.val,
ifelse(anova_type == 1,
summary(aov(DV ~ group, data=df))[[1]]$`Pr(>F)`[1],
car::Anova(aov(DV ~ group, data=df), type = anova_type)$`Pr(>F)`[1])))
for_return = pval < alpha
return(for_return)
}
close(pb)
parallel::stopCluster(cl)
return(mean(signif))
}
sim_pow_t_anova(3,20,c(11,11,11),1)
source("~/GitHub/puRduePsych/R/sim_pow_t_z_anova.R", echo=TRUE)
sim_pow_t_anova(3,20,c(11,11,11),1)
sim_pow_t_anova(1,20,1,1,mu=0)
sim_pow_t_anova(1,20,0,1,mu=0)
sim_pow_t_anova(2,20,c(0,1),1,mu=0)
warnings()
sim_pow_t_anova(2,20,c(0,1),1,mu=0)
sim_pow_t_anova(2,20,c(0,1),1,mu=0)
sim_pow_t_anova(2,20,c(0,1),1,mu=0)
sim_pow_t_anova(2,20,c(0,0,0),1,mu=0)
sim_pow_t_anova(3,20,c(0,0,0),1,mu=0)
sim_pow_t_anova(3,20,c(0,0,0),1,mu=0)
sim_pow_t_anova(3,20,c(0,0,0),1)
?pwr::pwr.anova.test
pwr::pwr.anova.test(3,20,0)
test_names = c("group1", "group2", "group3")
typeof(test_names)
source("~/GitHub/puRduePsych/R/sim_pow_t_z_anova.R", echo=TRUE)
sim_pow_t_anova(c("tapioca", "pudding", "sauce"),20,c(0,0,0),1)
source("~/GitHub/puRduePsych/R/sim_pow_t_z_anova.R", echo=TRUE)
source("~/GitHub/puRduePsych/R/sim_pow_t_z_anova.R", echo=TRUE)
sim_pow_t_anova(c("tapioca", "pudding", "sauce"),20,c(0,0,0),1)
source("~/GitHub/puRduePsych/R/sim_pow_t_z_anova.R", echo=TRUE)
sim_pow_t_anova(c("tapioca", "pudding", "sauce"),20,c(0,0,0),1)
sim_pow_t_anova(c("tapioca", "pudding", "sauce"),20,c(0,0,0),1)
sim_pow_t_anova(c("tapioca", "pudding", "sauce"),20,c(0,1,0),1)
?t.test
?puRduePsych::sim_dat_lm
